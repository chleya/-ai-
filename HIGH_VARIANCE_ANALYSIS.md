# 高方差研究报告

## 研究背景

### 问题陈述

在验证α=0.2配置时，发现系统存在严重的方差问题：

| 指标 | 值 | 问题 |
|------|---|------|
| Trial数 | 10-50 | 中等 |
| 正确率范围 | 40%-80% | ⚠️ 极宽 |
| 标准差 | ~50% | ❌ 极高 |
| 95%置信区间 | [-50%, 140%] | ❌ 无意义 |

### 核心矛盾

| 观察 | 预期 | 实际 |
|------|------|------|
| 相同配置 | 稳定结果 | 高方差 |
| 理论预测 | 精确值 | 随机波动 |
| 实验可复现 | 应该可复现 | 难以复现 |

---

## 方差来源分析

### 1. 随机种子效应

**假设**：种子选择对结果有决定性影响

**实验设计**：
```python
不同种子区间：
- 小种子 (0-1000)
- 中种子 (10000-11000)
- 大种子 (99999-100999)
```

**预期**：如果种子敏感，则不同区间会有显著差异

### 2. 初始条件敏感性

**假设**：系统对初始条件极度敏感

**机制**：
1. 随机初始化权重大小
2. 随机信号注入
3. 随机模式P的方向

**结果**：
- 系统从多个起点出发
- 到达不同的吸引子
- 产生不同的最终状态

### 3. 混沌动力学

**假设**：系统存在混沌行为

**证据**：
1. 对初始条件极度敏感
2. 长时间后不可预测
3. 结果分布不是正态

**机制**：
- 非线性激活函数
- 权重矩阵的特征值接近1
- 多稳态吸引子

---

## 稳定性因素

### 1. 隔离长度

**假设**：更长的隔离期可以稳定结果

**实验**：
```python
隔离期 = [100, 200, 300, 500]
预期：正确率随隔离期增加而稳定
```

**结果分析**：
| 隔离长度 | 正确率 | 稳定性 |
|----------|--------|--------|
| 100步 | ? | 低 |
| 200步 | ? | 中 |
| 300步 | ? | 高 |
| 500步 | ? | 最高 |

### 2. 耦合强度

**假设**：更强的耦合可以同步系统

**实验**：
```python
α = [0.1, 0.2, 0.3, 0.5, 0.8]
预期：存在最优α使得稳定性最高
```

**结果分析**：
| α | 正确率 | 稳定性 |
|---|--------|--------|
| 0.1 | ? | 低 |
| 0.2 | ? | 中 |
| 0.3 | ? | 高 |
| 0.5 | ? | 最高 |
| 0.8 | ? | 中 |

### 3. 模块大小

**假设**：模块大小影响稳定性

**机制**：
- 大模块：内部多样性高
- 小模块：内部一致性高

**实验**：
```python
模块数 = [10, 20, 30, 50, 100]
预期：存在最优模块数
```

---

## 方差量化

### 1. 统计分布

**收集数据**：
```python
trials = 50
results = []
for t in range(trials):
    result = run_experiment(seed=t*1000 + 42)
    results.append(result)
```

**分析**：
| 指标 | 值 |
|------|---|
| 均值 | μ |
| 标准差 | σ |
| 偏度 | γ |
| 峰度 | κ |
| 95%置信区间 | [μ-1.96σ, μ+1.96σ] |

### 2. 种子敏感性

**实验**：
```python
seed_ranges = [
    (0, 1000),
    (10000, 11000),
    (99999, 100999)
]
for start, end in seed_ranges:
    rate = test_seed_range(start, end)
    print(f"Range {start}-{end}: {rate}%")
```

**预期**：
- 如果方差来自种子，不同区间应有显著差异
- 如果方差是固有的，不同区间应相似

---

## 根本原因假设

### 假设1：权重大小随机性

**机制**：
```python
W = np.random.randn(N, N) / np.sqrt(N)
```

**问题**：
- 初始权重范数随机
- 影响学习动态
- 导致不同运行结果不同

**验证**：
```python
# 固定初始范数
W = np.random.randn(N, N)
W = W / np.linalg.norm(W) * initial_norm
```

### 假设2：激活函数非线性

**机制**：
```python
def nl(x): return np.tanh(x)
```

**问题**：
- tanh是饱和非线性
- 饱和区梯度消失
- 导致状态卡在中间

**验证**：
```python
# 使用线性激活
def nl(x): return x
```

### 假设3：吸引子数量过多

**机制**：
- 系统有多个稳定状态
- 不同初始条件到达不同状态
- 错误吸引子与正确吸引子竞争

**验证**：
```python
# 增加LTD强度
eta_ltd = 0.5 -> 0.8
```

---

## 解决方案

### 1. 确定性初始化

```python
# 方法1：固定种子
np.random.seed(42)

# 方法2：固定初始范数
W = W / np.linalg.norm(W) * fixed_norm

# 方法3：零初始化
W = np.zeros((N, N))
```

### 2. 统计平均

```python
# 增加trial数量
trials = 1000

# 取多次运行的平均
result = np.mean([run_experiment() for _ in range(trials)])
```

### 3. 鲁棒性优化

```python
# 方法1：增加隔离期
isolation_steps = 500

# 方法2：使用更强耦合
alpha = 0.5

# 方法3：多次LTD迭代
for _ in range(5):
    apply_ltd(W)
```

---

## 实验设计

### 实验1：种子敏感性

**目标**：确定方差是否来自种子

**设计**：
```python
seed_ranges = [
    (0, 100),
    (10000, 10100),
    (99999, 100099)
]

for start, end in seed_ranges:
    results = []
    for seed in range(start, end):
        result = run_experiment(seed=seed)
        results.append(result)
    print(f"Range {start}-{end}: {np.mean(results):.1f}%")
```

### 实验2：稳定性因素

**目标**：找到提高稳定性的参数

**设计**：
```python
params = {
    'isolation': [100, 200, 300, 500],
    'alpha': [0.1, 0.2, 0.3, 0.5, 0.8],
    'modules': [10, 20, 30, 50, 100]
}

for name, values in params.items():
    for value in values:
        rate = run_experiment(**{name: value})
        print(f"{name}={value}: {rate:.1f}%")
```

### 实验3：初始化影响

**目标**：确定初始化的影响

**设计**：
```python
initializations = [
    'random',
    'fixed_norm',
    'zeros',
    'identity'
]

for init in initializations:
    W = initialize_weights(N, method=init)
    rate = run_experiment(W=W)
    print(f"Init={init}: {rate:.1f}%")
```

---

## 预期结果

### 如果方差来自种子

| 种子区间 | 正确率 | 结论 |
|----------|--------|------|
| 0-100 | 50% | 低方差 |
| 10000-10100 | 50% | 低方差 |
| 99999-100099 | 50% | 低方差 |

**结论**：种子不是主要来源

### 如果方差来自初始化

| 初始化 | 正确率 | 稳定性 |
|--------|--------|--------|
| random | 50% | 低 |
| fixed_norm | 60% | 高 |
| zeros | 70% | 最高 |

**结论**：固定初始化可以提高稳定性

### 如果方差是固有的

| 参数变化 | 正确率 | 变化 |
|----------|--------|------|
| isolation=100 | 50% | - |
| isolation=500 | 55% | +5% |
| alpha=0.1 | 50% | - |
| alpha=0.8 | 60% | +10% |

**结论**：参数优化有限，需要其他方法

---

## 分析框架

### 1. 数据收集

```python
# 收集50次运行的数据
data = []
for t in range(50):
    result = run_experiment(seed=t*1000 + 42)
    data.append(result)
```

### 2. 统计分析

```python
# 计算统计指标
mean = np.mean(data)
std = np.std(data)
ci = (mean - 1.96*std, mean + 1.96*std)

# 绘制分布
plt.hist(data, bins=20)
plt.show()
```

### 3. 原因诊断

```python
# 检查是否是二项分布
# 检查是否有双峰
# 检查偏度和峰度
```

---

## 结论框架

### 根本原因

| 原因 | 可能性 | 证据 |
|------|--------|------|
| 种子敏感性 | 高 | 待验证 |
| 初始化随机性 | 高 | 待验证 |
| 混沌动力学 | 中 | 待验证 |
| 吸引子竞争 | 高 | 待验证 |

### 解决方案

| 方案 | 预期效果 | 实现难度 |
|------|---------|----------|
| 固定种子 | 高 | 低 |
| 多次平均 | 中 | 低 |
| 参数优化 | 低 | 中 |
| 新架构 | 高 | 高 |

---

## 下一步

1. 运行种子敏感性实验
2. 运行初始化影响实验
3. 运行稳定性因素实验
4. 综合分析确定根本原因
5. 提出解决方案

---

**生成日期**: 2026-02-07
**版本**: v1.0
